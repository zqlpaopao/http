# 1、点击浏览器请求过程

![image-20210120214559666](geekTime-http.assets/image-20210120214559666.png)



# 2、IP是怎么来的 DHCP

## 网络请求过程相同网段和不同网段

1. <font color=red size=5x>**网络请求首先检查是否是相同网段,如果是相同网段,会发送ARP请求,获取mac地址**</font>

2. <font color=r size=5x>**如果不是同一网段回请求网关,如果没配置网关,根本发不出去**</font>

<font color=red size=5x></font>



## 动态主机配置DHCP

动态主机配置协议（Dynamic Host Configuration Protocol），简称 DHCP。

1. <font color=red size=5x>**请求地址发送0.0.0.0的广播包,目标地址为255.255.255.255,广播包封装了 UDP，UDP 封装了 BOOTP。其实 DHCP 是 BOOTP 的增强版**</font>

2. <font color=r size=5x>**即使有多个DHCP服务器,总会有第一个去响应,给出ip**</font>

3. <font color=red size=5x>**请求的ip收到后,回应DHCP收到,==DHCP服务器收到后回应ACK,客户机表示收到,并将信息存储==**</font>

4. <font color=red size=5x>**客户机会在过去50%的时候去续租,根据新的回应跟新配置信息**</font>



# 3、物理层

物理层为设备之间的[数据通信](https://baike.baidu.com/item/数据通信/897073)提供传输媒体及互连设备，为[数据传输](https://baike.baidu.com/item/数据传输/2987565)提供可靠的环境。



# 4、数据链路层

即MAC层,媒体访问控制协议

帧是数据链路层的传送单位

数据链路层主要有两个功能 ：帧编码和误差纠正控制。帧编码意味着定义一个包含信息频率、位同步、源地址、目标地址以及其他控制信息的数据包。数据链路层协议又被分为两个子层 ：[逻辑链路控制](https://baike.baidu.com/item/逻辑链路控制/3530198)（LLC）协议和[媒体访问控制](https://baike.baidu.com/item/媒体访问控制/9719321)（MAC）协议。



# ==5、传输层==

传输层包含tcp和udp，也是学习的重点

## 1⃣️ TCP/IP模型和OSI模型简介



示意图

![image-20210303101403289](geekTime-http.assets/image-20210303101403289.png)



> <font color=red size=5x>**第一层链接层**</font>，也是数据链路层或者MAC层，底层以太网 、wife等原始数据包的发送
>
> <font color=red size=5x>**第二层网际层**</font>，机器MAC转换为IP地址构成巨大互联网交互、网络里找到设备在转化为MAC地址应答
>
> <font color=red size=5x>**第三层传输层**</font>，TCP、UDP等传输协议
>
> <font color=red size=5x>**第四层应用层**</font>，经过下层的封装，层协议较多，http、sftp、smtp、ssh等等



知道了tcp/ip的层级分布，那么我们看一下点击浏览器的过程在此都做了什么

![image-20210120214559666](geekTime-http.assets/image-20210120214559666.png)

![image-20210304095514686](geekTime-http.assets/image-20210304095514686.png)

> 1. <font color=red size=5x>**当收到一个请求，也就是process_layer2(buffer)**</font>的时候查看MAC头是否和自己是一样的，一样说明是发送给自己的
> 2. <font color=red size=5x>**然后调用process_layer3(buffer)**</font>，二层MAC已经被摘除，查看三层的ip头是否和自己的ip是一样的，一样的则是发给自己的，不是则转发出去
> 3. <font color=red size=5x>**假设用的tcp协议**</font>，process_tcp(buffer)，查看tcp头信息，这里有端口号，分发给不同的坚挺端口进行处理
> 4. <font color=red size=5x>**进行请求处理**</font>
> 5. <font color=red size=5x>**然后调用 send_layer3(buffer)。**</font>Buffer 里面已经有了 HTTP 的头和内容，以及 TCP 的头。在这个函数里面加一个 IP 的头，记录下源 IP 的地址和目标 IP 的地址。
> 6. <font color=red size=5x>**然后调用 send_layer2(buffer)。**</font>Buffer 里面已经有了 HTTP 的头和内容、TCP 的头，以及 IP 的头。这个函数里面要加一下 MAC 的头，记录下源 MAC 地址，得到的就是本机器的 MAC 地址和目标的 MAC 地址
> 7. <font color=red size=5x>**整理好信息，从网口发出**</font>



介绍完TCP/IP的四层模型，我们来看下和iso的osi的七层网络模型

![image-20210303111401255](geekTime-http.assets/image-20210303111401255.png)

> 第一层：物理层，TCP/IP 里无对应；
>
> 第二层：数据链路层，对应 TCP/IP 的链接层；
>
> 第三层：网络层，对应 TCP/IP 的网际层；
>
> 第四层：传输层，对应 TCP/IP 的传输层；
>
> 第五、六、七层：统一对应到 TCP/IP 的应用层。



## 2⃣️ 数据链路层

三个主要职责

> 1. <font color=green size=5x>**为IP模块发送和接收IP数据报**</font>
> 2. <font color=green size=5x>**为ARP模块发送ARP和接收ARP应答**</font>
> 3. <font color=green size=5x>**为RARP发送RARP请求和接收RARP应答**</font>

- IP协议大家都知道位于TCP/IP模型中中的网际层，上层是传输层，下层是链接层

- ARP叫做地址解析协议，使用IP地址换取MAC地址的一种协议
  - 当一个请求发出的时候，请求地址检查目的地址是否在同一网段，不再的话广播请求网关（通常是路由器），网关收到请求，回复收到加上MAC地址，发送到下一个中转或者目的主机
- RARP叫做逆地址解析协议
- 还有很多其他的协议，以太网，PPP协议（adsl宽带）以及loopback协议

### 1、IP协议

>  IP协议是TCP/Ip协议的狠心，所有的TCP、UDP、IGCP的数据都是以Ip数据格式传输的。
>
> IP协议是不可靠的，IP协议没有提供一种数据传达以后的处理机制，这被认为是上层协议TCP或者UDP要做的事
>
> 所以TCP事一个可靠的协议，而UDP就没有那么可靠。

**IP协议头信息**

![image-20210303141418517](geekTime-http.assets/image-20210303141418517.png)

> **版本号**：IP协议的版本，例如ipv4值为4
>
> **头部长度**：4位最大长度为0xF，盖子短表示单位事字节（4字节）
>
> **服务类型**：3位优先权字段+4位TOS字段+1位保留字段，4位TOS字段分别表示最小延时、最大吞吐量、最高可靠性、最小费用，其中最多有一个能置为1。应用程序根据实际需要来设置 TOS值，如ssh和telnet这样的登录程序需要的是最小延时的服务，文件传输ftp需要的是最大吞吐量的服务
>
> **总长度**：指整个IP数据报的长度，单位字节，即IP数据报的最大长度为65535字节（2的16次方），==由于MTU的限制，长度超过MTU的数据报将被分片传输==，---最大传输单元（Maximum Transmission Unit，MTU）用来通知对方所能接受[数据服务](https://baike.baidu.com/item/数据服务/23724818)[单元](https://baike.baidu.com/item/单元/32922)的最大尺寸，说明发送方能够接受的[有效载荷](https://baike.baidu.com/item/有效载荷/3653893)大小
>
> **标识**：唯一地标识主机发送的每一个数据报，其初始值是随机的，每发送一个数据报其值就加1。同一个数据报的所有分片都具有相同的标识值
>
> **标志**: 位1保留，位2表禁止分片(DF)，若设置了此位，IP模块将不对数据报进行分片，在此情况下若IP数据报超过MTU，IP模块将丢弃数据报并返回一个ICMP差错报文；位3标识更多分片(MF)，除了数据报的最后一个分片，其他分片都要把它设置为1
>
> 位偏移：分片相对原始IP数据报数据部分的偏移。实际的偏移值为该值左移3位后得到的，所以除了最后一个IP数据报分片外，每个IP分片的数据部分的长度都必须是8的整数倍
>
> **生存时间**:：数据报到达目的地之前允许经过的路由器跳数。TTL值被发送端设置，常设置为64。数据报在转发过程中每经过一个路由该值就被路由器减1.当TTL值为0时，路由器就将该数据包丢弃，并向源端发送一个ICMP差错报文。TTL可以防止数据报陷入路由循环
>
> **协议**: 区分IP协议上的上层协议。在Linux系统的/etc/protocols文件中定义了所有上层协议对应的协议字段，ICMP为1，TCP为6，UDP为17
>
> **头部校验和**： 由发送端填充接收端对其使用CRC算法校验，检查IP数据报头部在传输过程中是否损坏
>
> **源IP地址和目的IP地址**: 表示数据报的发送端和接收端。一般情况下这两个地址在整个数据报传递过程中保持不变，不论中间经过多少个路由器
>
>  选项：可变长的可选信息，最多包含40字节。选项字段很少被使用。可用的IP可选项有：
>   a. 记录路由: 记录数据包途径的所有路由的IP，这样可以追踪数据包的传递路径
>   b. 时间戳: 记录每个路由器数据报被转发的时间或者时间与IP地址对，这样就可以测量途径路由之间数据报的传输的时间
>   c. 松散路由选择: 指定路由器的IP地址列表数据发送过程中必须经过所有的路由器
>   d. 严格路由选择: 数据包只能经过被指定的IP地址列表的路由器
>   e. 上层协议(如TCP/UDP)的头部信息
>

​	TTL 8bit ：生存时间，数据报到达目的地之前经过的路由数，每经过一次路由就将该值减1，当TTL位0的时候，路由器就会将该数据报丢弃，8bit最大255，常设置为64



**IP路由选择**

> 最特殊的情况是主机对主机直连，那么主机根本不需要寻找路由，直接传递数据就好，依靠ARP协议广播就可以
>
> 主机经过若干个路由器和目的主机连接，那么路由器就要通过ip包的信息来为ip寻找下一个合适的目标来进行传递，如果数据包的TTL到期就丢弃
>
> 搜索路由表，优先搜索匹配主机，如果能找到和IP地址完全一致的目标主机，则将该包发向目标主机
>
> 搜索路由表，如果匹配主机失败，则匹配同子网的路由器，这需要“子网掩码(1.3.)”的协助。如果找到路由器，则将该包发向路由器。
>
> 搜索路由表，如果匹配同子网路由器失败，则匹配同网号路由器，如果找到路由器，则将该包发向路由器。
>
> 搜索路由表，如果以上都失败了，就搜索默认路由，如果默认路由存在，则发包
>
> 如果都失败了，就丢掉这个包。

　　这再一次证明了，ip包是不可靠的。因为它不保证送达。

**ARP协议**

> 1. ARP协议是一种解析协议，本来主机是完全不知道这个IP在哪个主机的哪个接口
> 2. 当主机要发一个ip包的时候，会首先查一下自己的ARP高速缓存(ip-MAC地址缓存对应表)
> 3. 如果查询的IP-MAC值对不存在，那么主机就像网络发送一个ARP广播协议包，这个包里面包含要查询的ip地址
> 4. 收到广播包的主机都查询自己的ip地址，如果发现和自己一样，那么就准备一个包含自己MAC地址的ARP包传送给ARP广播的主机
> 5. 而广播主机收到后，就放入缓存ARP的缓存中，发送官博的主机就会用心的ARP缓存数据发送数据包

任何系统

```go
arp -a
```



```go
? (169.254.0.32) at 0:f4:8d:a0:9:db on en0 [ethernet]
? (169.254.0.171) at 5c:80:b6:45:a2:63 on en0 [ethernet]
? (169.254.8.69) at 0:f4:8d:db:36:81 on en0 [ethernet]
? (169.254.9.124) at 9a:e7:bf:d:d4:a6 on en0 [ethernet]
? (169.254.10.1) at 72:d7:e6:bb:87:90 on en0 [ethernet]
? (169.254.11.88) at 50:e0:85:50:e0:d3 on en0 [ethernet]
? (169.254.14.160) at a0:c5:89:a3:fb:56 on en0 [ethernet]
? (169.254.17.14) at 2:c6:7e:4a:d2:36 on en0 [ethernet]
? (169.254.17.242) at 14:20:5e:10:b5:3c on en0 [ethernet]
```

ARP的高速缓存时间是20分钟



### 2、ICMP协议

百度百科的解释

> ICMP（Internet Control Message Protocol）Internet控制[报文](https://baike.baidu.com/item/报文/3164352)协议。它是[TCP/IP协议簇](https://baike.baidu.com/item/TCP%2FIP协议簇)的一个子协议，用于在IP[主机](https://baike.baidu.com/item/主机/455151)、[路由](https://baike.baidu.com/item/路由)器之间传递控制消息。==控制消息是指[网络通](https://baike.baidu.com/item/网络通)不通、[主机](https://baike.baidu.com/item/主机/455151)是否可达、[路由](https://baike.baidu.com/item/路由/363497)是否可用等网络本身的消息。==  <font color=red size=3x>这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用 </font>font>
>
> ICMP使用IP的基本支持，就像它是一个更高级别的协议，但是，ICMP实际上是IP的一个组成部分，必须由每个IP模块实现。 

> IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。

ICMP协议大致分为两类，一种是查询报文，一种是差错报文。其中查询报文有以下几种用途:

1. ping查询

2. 子网掩码查询（用于无盘工作站在初始化自身的时候初始化子网掩码）

3. 时间戳查询（可以用来同步时间）
4. **ICMP**的应用--Traceroute



**IP选路**

IP选路，即IP寻路，就是根据路由表中的记录，来决定当前数据报是直接交付（目的地址属于当前局域网）还是发往下一跳路由（隶属于不同的局域网）。

**静态路由选路**

查看路由表

```go
netstat -rn                                                                                            
Routing tables

Internet:
Destination        Gateway            Flags        Refs      Use   Netif Expire
default            172.16.63.254      UGSc          114        8     en0
10.8/16            10.9.0.1           UGSc            0        0   utun1
10.9/24            10.9.0.104         UGSc          107        0   utun1
10.9/16            10.9.0.1           UGSc            0        0   utun1
10.9.0.104         10.9.0.104         UH              1        0   utun1
10.29.114.134/32   10.9.0.1           UGSc            0        0   utun1
10.47.67.196/32    10.9.0.1           UGSc            0        0   utun1
10.111/16          10.9.0.1           UGSc            0        0   utun1
10.111.179.243/32  10.9.0.1           UGSc            0        0   utun1
10.168.100.103/32  10.9.0.1           UGSc            0        0   utun1
47.52.55.213/32    10.9.0.1           UGSc            0        0   utun1
47.75.96.181/32    10.9.0.1           UGSc            0        0   utun1
47.75.168.58/32    10.9.0.1           UGSc            0        0   utun1
47.91.193.192/32   10.9.0.1           UGSc            0        0   utun1
47.91.223.112/32   10.9.0.1           UGSc            0        0   utun1
47.93.84.213/32    10.9.0.1           UGSc            0        0   utun1
47.96.1.126/32     10.9.0.1           UGSc            0        0   utun1
```

Flags 解析

> U 表明该路由可用
>
> G表明该路由是到一个网关。如果没有这个标志，说明和Destination是直连的，而相应的Gateway应该直接给出Destination的地址。
>
> H表明该路由是到一个主机，如果没有该标志，说明Destination是一个网络，换句话说Destination就应该写成一个网络号和子网号的组合，而不包括主机号(主机号码处为0)，例如 10.9.0.104 
>
> D表明该路由是为重定向报文创建的
>
> M该路由已经被重定向报文修改

这样，IP选路的方式就可以更加具体化了。如下

1. 首先用IP地址来匹配那些带H标志的DestinationIP地址。

2. 如果1失败就匹配那些网络地址。

3. 如果2失败就发送到Default网关



# 6、TCP详解

来回顾一下上一章节的内容

![image-20210304095640841](geekTime-http.assets/image-20210304095640841.png)

TCP/IP协议的通信过程其实就是对应着的数据==入栈和出栈==的过程，数据发送方每层不断的封装首部和尾部，添加信息，出栈的过程，数据接收方每层不断的拆除首部和尾部，等到最终的数据

以上的以太网首部，更准确应该是MAC头



这一章我们来详细讲TCP

## 1、和UDP区别

既然讲到TCP，那么自然少不了它的好兄弟UDP，我们先来看下他们呢的区别

![image-20210304101619474](geekTime-http.assets/image-20210304101619474.png)



**面向报文和面向字节流区别**

> **面向报文**的传输方式是**应用层给UDP多长的报文，UDP就照样转发**，即一次发送一个报文，因此应用程序必须选择合适大小的报文，若报文太长，则==需要IP层分片==降低效率
>
> **面向字节流**，虽然应用程序和TCP的监护是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流，TCP有一个缓冲，当应用程序传递的数据块太长，TCP就可以把它划分的短一些再传输。



**全双工**

> 二台通讯设备之间，允许有双向的资料传输。udp在两台端设备间通信，但与tcp不同的是，udp需要两次连接。也就是说，每一次连接都是单向传输，所以说udp更偏向单工。
>
> tcp不同，一次连接中，双方都可以发送数据，所以是典型的全双工。

## 2、DNS

> DNS属于应用层
>
> 运行在用户主机上的某些应用程序需要将主机名转换为IP地址
>
> ==DNS既有TCP的使用，也有UDP的使用==
>
> ​	区域传输的时候使用的是TCP，其他时候是UDP
>
> ​	区域传输：dns的规范规bai定了2种类型的dns服务器，一个叫主dns服务器，一个叫辅助dns服务器。在一个区中主dns服务器从自己本机的数据文件中读取该区的dns数据信息，而辅助dns服务器则从区的权威dns服务器中读取该区的dns数据信息。当一个辅助dns服务器启动时，它需要与主dns服务器通信，并加载数据信息，这就叫做区传送（zone transfer）

## 3、TCP头信息

![image-20210304105034703](geekTime-http.assets/image-20210304105034703.png)

![image-20210304154520340](geekTime-http.assets/image-20210304154520340.png)

<font color=red size=5x>**头部最少占20字节**</font>

**4位头部长度：**标识该tcp头部有多少个32bit字（4字节）因为4位最大能表示15，所以tcp头部最长是60字节

> - URG标志，表示紧急指针是否有效
> - ACK标志，表示确认号是否有效。称携带ACK标志的tcp报文段位确认报文段
> - PSH标志，提示接收端应用程序应该立即从tcp接受缓冲区中读走数据，为接受后续数据腾出空间（如果应用程序不将接收的数据读走，它们就会一直停留在tcp缓冲区中）
> - RST标志，表示要求对方重新建立连接。携带RST标志的tcp报文段为复位报文段。
> - SYN标志，表示请求建立一个连接。携带SYN标志的tcp报文段为同步报文段。
> - FIN标志，表示通知对方本端要关闭连接了。携带FIN标志的tcp报文段为结束报文段。



TCP关注的几个问题

- 顺序问题
- 丢包问题
- 连接维护
- 流量控制
- 拥塞控制
- 粘包问题



## 4、TCP的连接建立

![image-20210304112124075](geekTime-http.assets/image-20210304112124075.png)

> 1. 一开始双方都处于CLOSE状态
> 2. 客户端发送SYN（表示请求建立连接）seq=x（系列号）给服务端，然后进入SYN_WAIT等待连接建立状态
> 3. 服务端收到回复SYN，seq=x+1，ack=y，进入SYN_RECV(连接等待接收状态)
> 4. 客服端收到SYN和ACK，然发送ACK的ACK之，后回复ACK=y+1 seq=x+1，后处于ESTABLISHED状态
> 5. 服务端收到ACK的ACK进入ESTABLEISHED状态
> 6. 客户端和服务端建立连接

以上为连接建立过程

### 1、为什么需要三次握手？

<font color=red size=5x>**为了防止已失效的连接请求报文==突然==又传到服务器，建立连接，造成服务端资源浪费**</font>

> 具体例子：在有网络延迟的情况下，客户端发送一个请求，在网络中延迟了，到了超时时间后，客户端任务失败，再次发送一个连接请求，这次正常到达服务端，随后，上次那个延迟的连接报文也到达了，如果没有三次握手，那么每来一个请求就建立一次连接，极大的浪费了服务端的资源，而有了三次握手，服务端收到一个请求，就会问客户端这是你的请求吗，客户端回答这个请求已经被抛弃了，然后服务端拒绝这个请求

### 2、包的序号为什么不能从1连续的

<font color=red size=5x>**为了防止已失效的连接请求数据段==突然==又传到服务器，造成数据错误**</font>

> 具体例子：客户端发送数据包1、2、3，但是3出了问题迷路了，1、2到达，服务端确认数据，客户端收到重新传3，此时3的数据发生变化，但是恰巧之前的那个3到达了，造成数据不是想要传输的
>
> 所以数据段的序号设置适合时间变化有关的，可以看成是一个32位的计数器,每4微妙加1,如果重复,大概需要4个小时,那个绕路的包会在TTL时间之后消失





### 3、 传输包顺序问题

> seq由计算机和时间生成的32位的随机序列号
>
> ack：确认序列号，值为seq+1
>
> 1. 客户端每次发送数据，TCP就给每个数据包分配一个序列号（seq=x），并且在一个特定的时间内等待服务器对分配的这个序列号进行确认（ack=x+1）
> 2. 如果客户端在一个特定时间内没有收到服务端的确认，则客户端会重传次数据包



### 4、 丢包问题

> A发送分组M1，发送完就等待B的确认，B收到了就会箱A发送确认，A收到确认后在发送分组M2，以此类推

## 5、可靠传输工作原理

#### 出现差错怎么办？

1、 **数据包传输丢失或者数据包错误**

 - 分组在传入的过程中，B在接收M1检测的时候出现问题，就丢弃，什么也不做，（不通知A收到有差错的包），因为分组有可能在传输过程中出问题，A只要一段时间没收到确认，就会重传，这就是==**超时重传**==
 -  要实现超时重传，就要在每次发包之后设置一个超时计时器，如果在设定内没收到，就重传，否则撤销定时器
 - 此处注意的三个细节
         1. A在发送完分组M1之后要保存其副本，防止超时重传
         2. 分组和确认分组都需要编号，编号是32位置的计数器和时间结合的序列，应答的是序列号+1的回复
         3. 超时定时器的设定要合理，防止时间太长，造成浪费，也应避免时间太短而造成不必要的重传

2、 **确认丢失和确认迟到**

![image-20210304143510361](geekTime-http.assets/image-20210304143510361.png)

- B向A发送的确认包丢失，A在超时计时器之后又收到这个分组M1
  - B不想上层交付M1
  - B向A发送确认，不能认为发送过就不再发送，因为A之所以重传，可能就是在超时时间内没收到确认

- B向A发送确认包迟到，A收到重复的确认包
  - A收到重复的就丢弃，B仍然后接收到重复的M1，同样丢弃，在重传确认分组



基于上面的确认和重传机制，**保证在不可靠的传输网络上实现可靠的通信*

像上述的这种可靠的传输协议常称为**自动重传请求ARQ**意思是重传的请求是自动的。接受方不需要请求发送方重传某个出错的分组。

#### 如何提高效率

流水线传输就是发送方可连续发送多个分组，不必每发送完一个分组就暂停等待对方的确认，这样可使信道上一只有数据不断的传送，更好的提高信道的利用率

流水线的传输就要用到ARQ协议和滑动窗口协议

**连续ARQ协议**

![image-20210304153244962](geekTime-http.assets/image-20210304153244962.png)

a表示发送方维持的发送窗口，位于发送窗口内的5个分组都可以连续发送出去，而不需要等待对方的确认

连续ARQ协议规定，发送方每收到一个确认，就把滑动窗口向前移动一个分组的位置，，图中下面就是收到第1个分组的确认将发送串口移动一个分组的位置
而接收方一般采用累计确认的方式，也就是说，接收方不必对收到的分组逐个确认，而是在收到几个分组之后，对**按序达到的最后一个分组发送确认**，这就表示到这个分组为止的所有分组都已经正确收到

累计确认有优点也有缺点，优点：容易实现，即使确认丢失也不必重传，缺点：不能向发送方即使的反映接收方已经收到的所有分组的信息
	例如分组中的发送了前5个分组，而中间的第3个分组丢失了，这时接收方只能对前两个分组发送确认，发送方无法得知后面三个分组的下落，然后重传，---go-back-N，可见当通信质量不好的时候，连续ARQ会带来很多负面影响



## 6、TCP可靠传输的实现

### 字节为单位的滑动窗口



















 **滑动窗口**

































- 连接维护
- 流量控制
- 拥塞控制
- 粘包问题

































